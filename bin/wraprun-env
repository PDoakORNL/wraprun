#!/usr/bin/env python

# The MIT License (MIT)
# 
# Copyright (c) 2015 M. Belhorn
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

'''
This module provides functions for setting the environment needed to run A.
Simpson's MPI wrapper for calling independent MPI programs in apruns MPMD mode.

The main function expects an aprun MPMD mode argument string. See the aprun man
page for details.

The rank IDs of the MPI processing elements (PEs) for each independent MPI
executable in the aprun call (which share a common MPI_COM_WORLD) are
extracted, grouped, and formed into environment variable strings compatible with
the MPI wrapper.

For a program running on N PEs, each PE with MPI_COM_WORLD rank RID is granted
an environment variable containing all the associated rank IDs (RID_X) in the
same group.  The environment variables take the form

  WRAPRUN_${RID}="$RID_1 RID_2 ... RID_N"

The function then constructs a string that sets the rank group and MPI wrapper
LD_PRELOAD environment variables and appends the aprun call. The string is
printed to STDOUT which can be evaluated by a calling shell in order to preserve
shell redirection and backgrounding in PBS submission scripts.  '''

from __future__ import print_function
import os
import sys


VERBOSE=False

def echo(string):
    '''Print string wrapped in echo so receiving shell doesn't attempt to
    execute the contents.
    '''
    print('''echo "{0}";'''.format(string))


def log(lvl, msg):
    '''Print log message at given level.'''
    log_string = 'wraprun [{lvl}]: {msg}'
    if VERBOSE or lvl in ['WARNING', 'ERROR']:
        echo(log_string.format(lvl=lvl, msg=msg))




import argparse
class Group(object):
    def __init__(self, arg_list, id, first_mpi_rank):
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument('--w-cd', dest='cd', default='./',
                help="Set cwd for a groups's processes.")

        self.wraprun, self.aprun_arglist = parser.parse_known_args(arg_list)
        self.wraprun.id = id
        self.pes = self._get_pes()

        last_mpi_rank = first_mpi_rank + self.pes
        self.ranks = [i for i in range(first_mpi_rank, last_mpi_rank)]

    def _get_pes(self):
        try:
            index = self.aprun_arglist.index('-n') + 1
            return int(self.aprun_arglist[index])
        except ValueError:
            log('ERROR', "Missing aprun '-n' PE argument for executable "
                    "'{g}' with signature ".format(g=self.wraprun.id))
            log('ERROR', "'{s}'".format(s=' '.join(self.aprun_arglist)))
            sys.exit(1)

    def has_arg(self, arg):
        '''Return true if arg in set of aprun arguments'''
        return True if arg in self.aprun_arglist else False

    def arg_string(self):
        return ' '.join(self.aprun_arglist)

    def env_string(self):
        var = "{id} {cd}"
        return var.format(**(self.wraprun.__dict__))



class Arguments(object):
    '''A class to parse and encapsulate arguments to a wraprun call and it's
    underlying aprun call.'''
    REQUIRED_APRUN_ARGS = {'-b':None,}

    def __init__(self):
        self.wraprun, remaining_arglist = self._parse_cli()
        global VERBOSE
        VERBOSE = self.wraprun.debug
        self.groups = self._parse_group_args(remaining_arglist)
        self.aprun_arglist = self._parse_aprun_global_args(self.groups[0])
        
    def _parse_cli(self):
        '''Parse CLI arguments for wraprun specific options and aprun specific
        arguments.'''
        cli_parser = argparse.ArgumentParser(
                description='Generates shell-evaluable string to set '
                'the wraprun environment.')
        cli_parser.add_argument('--w-debug', dest='debug', action='store_true',
                help='Show debugging information.')

        return cli_parser.parse_known_args()

    def _parse_group_args(self, arglist):
        groups = []
        total_pes = 0
        for id, group_args in enumerate(self.find_groups(arglist)):
            group = Group(group_args, id, total_pes)
            groups.append(group)
            total_pes+=group.pes
        return groups

    @staticmethod
    def find_groups(arglist):
        '''Given a 1D list of wraprun arguments, return a 2D list of arguments
        grouped by respective MPMD executable block.''' 
        return [i.split() for i in (' '.join(arglist)).split(':')]

    def _parse_aprun_global_args(self, first_group):
        aprun_arglist = ['aprun']
        for arg, value in self.REQUIRED_APRUN_ARGS.items():
            if not first_group.has_arg(arg):
                log('WARNING',
                        "Adding required aprun argument '{a}'.".format(a=arg))
                aprun_arglist.append(arg)
                if value is not None:
                    aprun_arglist.append(arg)
        return aprun_arglist

    def group_arg_strings(self):
        return [group.arg_string() for group in self.groups]

    def groups_arg_string(self):
        return ' : '.join(self.group_arg_strings())

    def aprun_arg_string(self):
        arg_strings = {
                'aprun': ' '.join(self.aprun_arglist),
                'groups': self.groups_arg_string(),
                }
        return '{aprun} {groups}'.format(**arg_strings)


class Wraprun(object):
    def __init__(self):
        self.args = Arguments()
        self.groups = self.args.groups
        self.env = self._update_env()

    def _update_env(self):
        env = {}
        for group in self.groups:
            for rank in group.ranks:
                name = 'WRAPRUN_{rank}'.format(
                        rank=rank)
                env[name] = group.env_string()
        env['LD_PRELOAD'] = self._get_preload_path()
        return env

    def _get_preload_path(self):
        if 'WRAPRUN_PRELOAD' not in os.environ.keys():
            log('WARNING', 'Environment variable WRAPRUN_PRELOAD not set. '
                'Using alternate MPI wrapper.')
        return os.environ.pop('WRAPRUN_PRELOAD',
                '/lustre/atlas/proj-shared/stf007/libsplit.so')

    def env_string(self):
        '''Return the set of shell-evaluable strings needed to
        set the environment.'''
        return ['{name}="{value}"'.format(name=name, value=value)
                for name, value in sorted(self.env.items())]

    def eval(self):
        for env in self.env_string():
            print(env)
        print(self.args.aprun_arg_string())


def main():
    '''Perform the sequence of steps needed to print the environment shell
    commands.
    '''

    wraprun = Wraprun()
    log('INFO', 'Launching aprun in wrapped environment')
    if wraprun.args.wraprun.debug:
        log('DEBUG', 'Setting environment variables:')
        for env in wraprun.env_string():
            log('DEBUG', env)
        log('DEBUG', 'Command line called:')
        log('DEBUG', wraprun.args.aprun_arg_string())
    wraprun.eval()



#===============================================================================
if __name__ == '__main__':
    main()

