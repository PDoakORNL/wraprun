#!/usr/bin/env python

# The MIT License (MIT)
# 
# Copyright (c) 2015 M. Belhorn
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

'''
This module provides functions for setting the environment needed to run A.
Simpson's MPI wrapper for calling independent MPI programs in apruns MPMD mode.

The main function expects an aprun MPMD mode argument string. See the aprun man
page for details.

The rank IDs of the MPI processing elements (PEs) for each independent MPI
executable in the aprun call (which share a common MPI_COM_WORLD) are
extracted, grouped, and formed into environment variable strings compatible with
the MPI wrapper.

For a program running on N PEs, each PE with MPI_COM_WORLD rank RID is granted
an environment variable containing all the associated rank IDs (RID_X) in the
same group.  The environment variables take the form

  WRAPRUN_${RID}="$RID_1 RID_2 ... RID_N"

The function then constructs a string that sets the rank group and MPI wrapper
LD_PRELOAD environment variables and appends the aprun call. The string is
printed to STDOUT which can be evaluated by a calling shell in order to preserve
shell redirection and backgrounding in PBS submission scripts.  '''

from __future__ import print_function
import os
import sys


VERBOSE=False

def echo(string):
    '''Print string wrapped in echo so receiving shell doesn't attempt to
    execute the contents.
    '''
    print('''echo "{0}";'''.format(string))


def log(lvl, msg):
    '''Print log message at given level.'''
    log_string = 'wraprun [{lvl}]: {msg}'
    if VERBOSE or lvl in ['WARNING', 'ERROR']:
        echo(log_string.format(lvl=lvl, msg=msg))




import argparse
class Group(object):
    def __init__(self, arg_list, id, first_mpi_rank):
        parser = argparse.ArgumentParser(add_help=False)
        parser.add_argument('--w-cd', dest='cd', default='./',
                help="Set cwd for a groups's processes.")

        self.wraprun, self.aprun_arglist = parser.parse_known_args(arg_list)
        self.wraprun.id = id
        self.pes = self._get_pes()

        last_mpi_rank = first_mpi_rank + self.pes
        self.ranks = [i for i in range(first_mpi_rank, last_mpi_rank)]

    def _get_pes(self):
        try:
            index = self.aprun_arglist.index('-n') + 1
            return int(self.aprun_arglist[index])
        except ValueError:
            log('ERROR', "Missing aprun '-n' PE argument for executable "
                    "'{g}' with signature ".format(g=self.wraprun.id))
            log('ERROR', "'{s}'".format(s=' '.join(self.aprun_arglist)))
            sys.exit(1)

    def has_arg(self, arg):
        '''Return true if arg in set of aprun arguments'''
        return True if arg in self.aprun_arglist else False

    def arg_string(self):
        return ' '.join(self.aprun_arglist)

    def env_string(self):
        var = "{id} {cd}"
        return var.format(**(self.wraprun.__dict__))


class Arguments(object):
    '''A class to parse and encapsulate arguments to a wraprun call and it's
    underlying aprun call.'''
    REQUIRED_APRUN_ARGS = {'-b':None,}

    def __init__(self):
        self._args = {
                "wraprun": None,
                "aprun": None,
                "groups": None,
                "unprocessed": None,
                }
        self._parse_cli()
        self._parse_groups()
        self._parse_global_args()

    @property
    def wraprun(self):
        return self._args["wraprun"]

    @wraprun.setter
    def wraprun(self, namespace):
        self._args["wraprun"] = namespace

    @property
    def groups(self):
        return self._args["groups"]

    @groups.setter
    def groups(self, group_list):
        self._args["groups"] = group_list

    @property
    def aprun(self):
        return self._args["aprun"]

    @aprun.setter
    def aprun(self, aprun_global_arglist):
        self._args["aprun"] = aprun_global_arglist

    @property
    def _unprocessed(self):
        return self._args["unprocessed"]

    @_unprocessed.setter
    def _unprocessed(self, arglist):
        self._args["unprocessed"] = arglist

    def _parse_cli(self):
        '''Parse CLI arguments for wraprun specific options and aprun specific
        arguments.'''
        cli_parser = argparse.ArgumentParser(
                description='Generates shell-evaluable string to set '
                'the wraprun environment.')
        cli_parser.add_argument('--w-debug', dest='debug', action='store_true',
                help='Show debugging information.')

        self.wraprun, self._unprocessed = cli_parser.parse_known_args()

        # Update global flags
        global VERBOSE
        VERBOSE = self.wraprun.debug

    def _group_arglists(self):
        arglist = self._unprocessed
        start = 0
        end = arglist.index(':')
        while end is not None:
            yield arglist[start:end]
            start = end + 1
            try:
                end = arglist.index(':', start)
            except ValueError:
                end = None
        yield arglist[start:]

    def _parse_groups(self):
        self.groups = []
        groups = self.groups
        total_pes = 0
        for id, group_args in enumerate(self._group_arglists()):
            group = Group(group_args, id, total_pes)
            groups.append(group)
            total_pes+=group.pes

    def _parse_global_args(self):
        first_group = self.groups[0]
        args = ['aprun']
        for arg, value in self.REQUIRED_APRUN_ARGS.items():
            if not first_group.has_arg(arg):
                log('WARNING',
                        "Adding required aprun argument '{a}'.".format(a=arg))
                args.append(arg)
                if value is not None:
                    args.append(arg)
        self.aprun = args

    # TODO: These methods need to be optimized for reduced memory use and speed.
    def _group_strings(self):
        for group in self.groups:
            yield group.arg_string()

    def _groups_arg_string(self):
        return ' : '.join(self._group_strings())

    def string(self):
        arg_strings = {
                'aprun': ' '.join(self.aprun),
                'groups': self._groups_arg_string(),
                }
        return '{aprun} {groups}'.format(**arg_strings)

class WraprunError(Exception):
    pass

from collections import namedtuple
File = namedtuple('File', ['fd', 'path'])

class Wraprun(object):
    def __init__(self):
        self.args = Arguments()
class Wraprun(object):
    def __init__(self):
        self.args = Arguments()
        self.groups = self.args.groups

        self._file = File(fd=None, path=None)
        self._job_id = None
        self.env = {
                'LD_PRELOAD': self._set_preload_path(),
                'WRAPRUN_FILE': self.file.path,
                }
    
    @property
    def job_id(self):
        '''Determine PBS job ID from the environment.
        
        If not available (for instance if called outside a PBS script), an error
        is raised unless the script is run with debugging flags.
        '''
        if self._job_id is None:
            try:
                self._job_id = os.environ["PBS_JOBID"]
            except KeyError:
                if self.args.wraprun.debug:
                    self._job_id = '000000'
                else:
                    raise
        return self._job_id

    def _get_account(self):
        '''Return the account string under which the parent PBS script is
        running.
        '''
        import subprocess
        qstat = subprocess.Popen(
                ['qstat', '-f', self.job_id], stdout=subprocess.PIPE)
        for line in qstat.stdout.readlines():
            if 'Account_Name' in line:
                account = (line[19:-1]).lower()
                break
        else:
            if self.args.wraprun.debug:
                account = 'stf007'
            else:
                raise WraprunError("Cannot determine account name.")
        return account

    @property
    def file(self):
        if self._file.path is None:
            import tempfile
            dir = os.path.join(
                    os.environ["MEMBERWORK"],
                    self._get_account(),
                    ".wraprun")
            try:
                os.makedirs(dir, 0700)
            except OSError as err:
                if err.errno is not 17:
                    raise
            fd, path = tempfile.mkstemp(
                    prefix='tmp{job}_'.format(job=self.job_id),
                    suffix='.wraprun',
                    dir=dir, text=True)
            self._file = File(fd, path)
        return self._file
   
    def _write_data_file(self):
        '''Generate the data for each rank to be written to the tmp file.'''
        with os.fdopen(self.file.fd, 'a') as f:
            for group in self.groups:
                for rank in group.ranks:
                    f.write(group.env_string() + "\n")

    def _set_preload_path(self):
        if 'WRAPRUN_PRELOAD' not in os.environ.keys():
            log('WARNING', 'Environment variable WRAPRUN_PRELOAD not set. '
                'Using alternate MPI wrapper.')
        return os.environ.pop('WRAPRUN_PRELOAD',
                '/lustre/atlas/proj-shared/stf007/libsplit.so')

    def _env_strings(self):
        '''Return the set of shell-evaluable strings needed to
        set the environment.
        '''
        for name, value in self.env.items():
            yield '{n}="{v}";'.format(n=name, v=value)

    def eval(self):
        self._write_data_file()
        for env in self._env_strings():
            print(env)
        print(self.args.string())


def main():
    '''Produces the data needed by the MPI wrapper library to run aprun flexibly
    in MPMD mode.
    '''
    wraprun = Wraprun()
    log('INFO', 'Launching aprun in wrapped environment')
    if wraprun.args.wraprun.debug:
        log('DEBUG', 'Environment set:')
        for env in wraprun._env_strings():
            log('DEBUG', env)
        log('DEBUG', 'Command line called:')
        log('DEBUG', wraprun.args.string())
    wraprun.eval()



#===============================================================================
if __name__ == '__main__':
    main()

