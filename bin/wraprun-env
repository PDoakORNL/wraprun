#!/usr/bin/env python

# The MIT License (MIT)
# 
# Copyright (c) 2015 M. Belhorn
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

'''
This module provides functions for setting the environment needed to run A.
Simpson's MPI wrapper for calling independent MPI programs in apruns MPMD mode.

The main function expects an aprun MPMD mode argument string. See the aprun man
page for details.

The rank IDs of the MPI processing elements (PEs) for each independent MPI
executable in the aprun call (which share a common MPI_COM_WORLD) are
extracted, grouped, and formed into environment variable strings compatible with
the MPI wrapper.

For a program running on N PEs, each PE with MPI_COM_WORLD rank RID is granted
an environment variable containing all the associated rank IDs (RID_X) in the
same group.  The environment variables take the form

  WRAPRUN_${RID}="$RID_1 RID_2 ... RID_N"

The function then constructs a string that sets the rank group and MPI wrapper
LD_PRELOAD environment variables and appends the aprun call. The string is
printed to STDOUT which can be evaluated by a calling shell in order to preserve
shell redirection and backgrounding in PBS submission scripts.  '''

from __future__ import print_function
import os
import sys


VERBOSE=False

def echo(string):
    '''Print string wrapped in echo so receiving shell doesn't attempt to
    execute the contents.
    '''
    print('''echo "{0}";'''.format(string))


def log(lvl, msg):
    '''Print log message at given level.'''
    log_string = 'wraprun [{lvl}]: {msg}'
    if VERBOSE or lvl in ['WARNING', 'ERROR']:
        echo(log_string.format(lvl=lvl, msg=msg))




import argparse
class Rank(object):

    # Ordered tuple of keys in output file lines.
    FILE_CONTENT = (
            'color',
            'path',
            )

    FILE_FORMAT = ' '.join(('{{{0}}}'.format(k) for k in FILE_CONTENT))

    def __init__(self, rank, color, **kwargs):
        self.rank = rank
        self._data = {
                'color': color,
                'path': './', 
                }
        self._data.update(kwargs)

    def string(self):
        return Rank.FILE_FORMAT.format(**self._data)

    @property
    def color(self):
        return self._data['color']



class ArgAction(argparse.Action):
    def __init__(self, *args, **kwargs):
        super(ArgAction, self).__init__(*args, **kwargs)
        self.split = False
        self.cli = None
        
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)
        self.cli = [option_string, values]
    
class FlagAction(ArgAction):
    def __init__(self, *args, **kwargs):
        default = kwargs.pop('default', False)
        nargs = kwargs.pop('nargs', 0)
        super(FlagAction, self).__init__(*args, default=default, nargs=0, **kwargs)
        
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)
        self.cli = [option_string]
    
class PesAction(ArgAction):
    def __init__(self, *args, **kwargs):
        super(PesAction, self).__init__(*args, **kwargs)
        self.split = True
        
    def __call__(self, parser, namespace, values, option_string=None):
        v = [int(i) for i in values.split(',')]
        setattr(namespace, self.dest, v)
        self.cli = [option_string, str(sum(v))]
    
class PathAction(ArgAction):
    def __init__(self, *args, **kwargs):
        super(PathAction, self).__init__(*args, **kwargs)
        self.split = True
        self.is_aprun_arg = False
        
    def __call__(self, parser, namespace, values, option_string=None):
        v = [i for i in values.split(',')]
        setattr(namespace, self.dest, v)


class GroupError(Exception):
    pass


class Group(object):
    def __init__(self, arg_list, id, first_color, first_rank):
        wparser = argparse.ArgumentParser(add_help=False)
        # Aprun options (2015/06/25):
        # FIXME: '-b' should be parsed in Arguments class with global aprun
        # options and should raise an error if caught in a group.
        wparser.add_argument('-b', dest='bypass', action=FlagAction)
        wparser.add_argument('--w-cd', dest='path', default=['./'], action=PathAction)
        wparser.add_argument('-n', dest='pes', required=True, action=PesAction)
        wparser.add_argument('-a', dest='arch', action=ArgAction)
        wparser.add_argument('-cc', dest='cpu_list', action=ArgAction)
        wparser.add_argument('-cp', dest='cpu_placement_file', action=ArgAction)
        wparser.add_argument('-d', dest='depth', action=ArgAction)
        wparser.add_argument('-L', dest='node_list', action=ArgAction)
        wparser.add_argument('-N', dest='pes_per_node', action=ArgAction)
        wparser.add_argument('-S', dest='pes_per_numa_node', action=ArgAction)
        wparser.add_argument('-sl', dest='numa_node_list', action=ArgAction)
        wparser.add_argument('-sn', dest='numa_nodes_per_node', action=ArgAction)
        wparser.add_argument('-ss', dest='strict_memory', action=FlagAction)
        wparser.add_argument('exe', nargs=argparse.REMAINDER)

        self.wraprun = wparser.parse_args(arg_list)
        self.nsplits = self._get_nsplit(wparser)
        self._scale_split_args(wparser)
        
        self.ranks = self._set_ranks(first_rank, first_color)
        self.cli_arglist = [s for a in wparser._actions if getattr(a, 'cli', None) is not None for s in a.cli] + self.wraprun.exe
        
    def scan_splits(self, parser):
        for action in parser._actions:
            v = getattr(self.wraprun, action.dest, None)
            if getattr(action, 'split', False) and v is not None:
                yield v, action

    def _get_nsplit(self, parser):
        splits = set((len(arg) for arg, _ in self.scan_splits(parser) if len(arg) != 1))
        if len(splits) > 1:
            raise GroupError('Inconsistent splits given {}'.format(splits))
        else:
            return max(splits) if splits else 1

    def _scale_split_args(self, parser):
        for v, action in self.scan_splits(parser):
            if len(v) != self.nsplits:
                setattr(self.wraprun, action.dest, v * self.nsplits) 

    def _set_ranks(self, first_rank, first_color):
        ranks = []
        for subgroup_id, n_pes_in_sg in enumerate(self.wraprun.pes):
            color = first_color + subgroup_id
            for pid in range(n_pes_in_sg):
                rank_id = subgroup_id * n_pes_in_sg + pid + first_rank
                rank = Rank(rank_id, color, path=self.wraprun.path[subgroup_id])
                ranks.append(rank)
        return ranks

    @property
    def last_color(self):
        return self.ranks[-1].color

    @property
    def last_rank(self):
        return self.ranks[-1].rank

    @property
    def total_pes(self):
        return sum(self.wraprun.pes)

    def has_arg(self, arg):
        '''Return true if arg in set of aprun arguments'''
        return True if getattr(self.wraprun, arg, None) is not None else False

    def arg_string(self):
        return ' '.join(self.cli_arglist)


class Arguments(object):
    '''A class to parse and encapsulate arguments to a wraprun call and it's
    underlying aprun call.'''
    REQUIRED_APRUN_ARGS = {'bypass':None,}

    def __init__(self):
        self._args = {
                "wraprun": None,
                "aprun": None,
                "groups": None,
                "unprocessed": None,
                }
        self._parse_cli()
        self._parse_groups()
        self._parse_global_args()

    @property
    def wraprun(self):
        return self._args["wraprun"]

    @wraprun.setter
    def wraprun(self, namespace):
        self._args["wraprun"] = namespace

    @property
    def groups(self):
        return self._args["groups"]

    @groups.setter
    def groups(self, group_list):
        self._args["groups"] = group_list

    @property
    def aprun(self):
        return self._args["aprun"]

    @aprun.setter
    def aprun(self, aprun_global_arglist):
        self._args["aprun"] = aprun_global_arglist

    @property
    def _unprocessed(self):
        return self._args["unprocessed"]

    @_unprocessed.setter
    def _unprocessed(self, arglist):
        self._args["unprocessed"] = arglist

    def _parse_cli(self):
        '''Parse CLI arguments for wraprun specific options and aprun specific
        arguments.'''
        cli_parser = argparse.ArgumentParser(
                description='Generates shell-evaluable string to set '
                'the wraprun environment.')
        cli_parser.add_argument('--w-debug', dest='debug', action='store_true',
                help='Show debugging information.')

        self.wraprun, self._unprocessed = cli_parser.parse_known_args()

        # Update global flags
        global VERBOSE
        VERBOSE = self.wraprun.debug

    def _group_arglists(self):
        arglist = self._unprocessed
        start = 0
        try:
            end = arglist.index(':')
        except ValueError:
            end = None
        while end is not None:
            yield arglist[start:end]
            start = end + 1
            try:
                end = arglist.index(':', start)
            except ValueError:
                end = None
        yield arglist[start:]

    def _parse_groups(self):
        self.groups = []
        groups = self.groups
        starting_color = 0
        starting_rank = 0
        for id, group_args in enumerate(self._group_arglists()):
            group = Group(group_args, id, starting_color, starting_rank)
            groups.append(group)
            starting_color = group.last_color + 1
            starting_rank = group.last_rank + 1

    def _parse_global_args(self):
        first_group = self.groups[0]
        args = ['aprun']
        for arg, value in self.REQUIRED_APRUN_ARGS.items():
            if not first_group.has_arg(arg):
                log('WARNING',
                        "Adding required aprun argument '{a}'.".format(a=arg))
                args.append(arg)
                if value is not None:
                    args.append(arg)
        self.aprun = args

    # TODO: These methods need to be optimized for reduced memory use and speed.
    def _group_strings(self):
        for group in self.groups:
            yield group.arg_string()

    def _groups_arg_string(self):
        return ' : '.join(self._group_strings())

    def string(self):
        arg_strings = {
                'aprun': ' '.join(self.aprun),
                'groups': self._groups_arg_string(),
                }
        return '{aprun} {groups}'.format(**arg_strings)

class WraprunError(Exception):
    pass

from collections import namedtuple
File = namedtuple('File', ['fd', 'path'])

class Wraprun(object):
    def __init__(self):
        self.args = Arguments()
class Wraprun(object):
    def __init__(self):
        self.args = Arguments()
        self.groups = self.args.groups

        self._file = File(fd=None, path=None)
        self._job_id = None
        self.env = {
                'LD_PRELOAD': self._set_preload_path(),
                'WRAPRUN_FILE': self.file.path,
                }
    
    @property
    def job_id(self):
        '''Determine PBS job ID from the environment.
        
        If not available (for instance if called outside a PBS script), an error
        is raised unless the script is run with debugging flags.
        '''
        if self._job_id is None:
            try:
                self._job_id = os.environ["PBS_JOBID"]
            except KeyError:
                if self.args.wraprun.debug:
                    self._job_id = '000000'
                else:
                    raise
        return self._job_id

    def _get_account(self):
        '''Return the account string under which the parent PBS script is
        running.
        '''
        if self.job_id != '000000':
            import subprocess
            qstat = subprocess.Popen(
                    ['qstat', '-f', self.job_id], stdout=subprocess.PIPE)
            for line in qstat.stdout.readlines():
                if 'Account_Name' in line:
                    account = (line[19:-1]).lower()
                    break
            else:
                if self.args.wraprun.debug:
                    account = 'stf007'
                else:
                    raise WraprunError("Cannot determine account name.")
        else:
            account = 'stf007'
        return account

    @property
    def file(self):
        if self._file.path is None:
            import tempfile
            dir = os.path.join(
                    os.environ["MEMBERWORK"],
                    self._get_account(),
                    ".wraprun")
            try:
                os.makedirs(dir, 0700)
            except OSError as err:
                if err.errno is not 17:
                    raise
            fd, path = tempfile.mkstemp(
                    prefix='tmp{job}_'.format(job=self.job_id),
                    suffix='.wraprun',
                    dir=dir, text=True)
            self._file = File(fd, path)
        return self._file
   
    def _write_data_file(self):
        '''Generate the data for each rank to be written to the tmp file.'''
        with os.fdopen(self.file.fd, 'a') as f:
            for group in self.groups:
                for rank in group.ranks:
                    f.write(rank.string() + "\n")

    def _set_preload_path(self):
        if 'WRAPRUN_PRELOAD' not in os.environ.keys():
            log('WARNING', 'Environment variable WRAPRUN_PRELOAD not set. '
                'Using alternate MPI wrapper.')
        return os.environ.pop('WRAPRUN_PRELOAD',
                '/lustre/atlas/proj-shared/stf007/libsplit.so')

    def _env_strings(self):
        '''Return the set of shell-evaluable strings needed to
        set the environment.
        '''
        for key, value in self.env.items():
            yield 'export {key}="{value}"'.format(key=key, value=value)

    def eval(self):
        self._write_data_file()
        for env in self._env_strings():
            print(env, end=';')
        print(self.args.string())


def main():
    '''Produces the data needed by the MPI wrapper library to run aprun flexibly
    in MPMD mode.
    '''
    wraprun = Wraprun()
    log('INFO', 'Launching aprun in wrapped environment')
    if wraprun.args.wraprun.debug:
        log('DEBUG', 'Environment set:')
        for env in wraprun._env_strings():
            log('DEBUG', env)
        log('DEBUG', 'Command line called:')
        log('DEBUG', wraprun.args.string())
    wraprun.eval()

    if wraprun.args.wraprun.debug:
        log('DEBUG', 'Contents of output file:')
        with open(wraprun.file.path) as f:
            width = len(str(wraprun.groups[-1].last_rank))
            for ln, line in enumerate(f):
                log('DEBUG', '  {ln:0{width}d}|{line}'.format(
                    ln=ln, width=width, line=line[:-1]))



#===============================================================================
if __name__ == '__main__':
    main()

