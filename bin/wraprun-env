#!/usr/bin/env python

# The MIT License (MIT)
# 
# Copyright (c) 2015 M. Belhorn
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

'''
This module provides functions for setting the environment needed to run A.
Simpson's MPI wrapper for calling independent MPI programs in apruns MPMD mode.

The main function expects an aprun MPMD mode argument string. See the aprun man
page for details.

The rank IDs of the MPI processing elements (PEs) for each independent MPI
executable in the aprun call (which share a common MPI_COM_WORLD) are
extracted, grouped, and formed into environment variable strings compatible with
the MPI wrapper.

For a program running on N PEs, each PE with MPI_COM_WORLD rank RID is granted
an environment variable containing all the associated rank IDs (RID_X) in the
same group.  The environment variables take the form

  WRAPRUN_${RID}="$RID_1 RID_2 ... RID_N"

The function then constructs a string that sets the rank group and MPI wrapper
LD_PRELOAD environment variables and appends the aprun call. The string is
printed to STDOUT which can be evaluated by a calling shell in order to preserve
shell redirection and backgrounding in PBS submission scripts.  '''

from __future__ import print_function
import os


VERBOSE=False

def echo(string):
    '''Print string wrapped in echo so receiving shell doesn't attempt to
    execute the contents.
    '''
    print('''echo "{0}";'''.format(string))


def log(lvl, msg):
    '''Print log message at given level.'''
    log_string = 'wraprun [{lvl}]: {msg}'
    if VERBOSE or lvl in ['WARNING', 'ERROR']:
        echo(log_string.format(lvl=lvl, msg=msg))


# Get the PRELOAD lib from the environment else use an alternate version.
if 'WRAPRUN_PRELOAD' not in os.environ.keys():
    log('WARNING', 'Environment variable WRAPRUN_PRELOAD not set. '
        'Using alternate MPI wrapper.')
LIB_PATH=os.environ.pop('WRAPRUN_PRELOAD',
        '/lustre/atlas/proj-shared/stf007/libsplit.so')

GROUP_VAR_FORMAT='WRAPRUN_{rank}'


def parser():
    '''
    Parse CLI arguments for wraprun specific options and aprun specific
    arguments.
    '''
    import argparse
    self = argparse.ArgumentParser(
            description='Generates shell-evaluable string to set '
            'the wraprun environment.')
    self.add_argument('--w-debug', dest='debug', action='store_true',
            help='Show debugging information.')
    local_args, aprun_args = self.parse_known_args()
    return local_args, aprun_args


def _parse_independent_args(independent_args):
    '''Parse arguments passed in each executable block (separated by ':') for
    flags that modify the behavior of each group separately.'''
    import argparse
    self = argparse.ArgumentParser()
    self.add_argument('--w-cd', dest='cd', default='./',
            help="Set current working directory of this groups's processes.")
    group_args, aprun_args = self.parse_known_args(independent_args)
    return group_args, aprun_args


def get_independent_argstrings(aprun_arg_list):
    '''Return a list of each independent program's argument list.'''
    aprun_arg_string = ' '.join(aprun_arg_list)
    group_arg_strings = aprun_arg_string.split(':')
    group_arg_lists = [i.split() for i in group_arg_strings]
    group_wraprun_args = []
    group_aprun_args = []
    for args in group_arg_lists:
        wraprun_args, aprun_args = _parse_independent_args(args)
        group_wraprun_args.append(wraprun_args)
        group_aprun_args.append(aprun_args)
    aprun_arg_list = [arg for args in group_aprun_args for arg in args]
    return group_wraprun_args, group_aprun_args


def extract_group_ids(independent_args):
    '''Return a list of group rank ID lists extracted from aprun arguments.'''
    total_pes = 0
    groups = []
    for args in independent_args:
        pes_index = args.index('-n') + 1
        pes = int(args[pes_index])
        current_pes = int(total_pes)
        total_pes+=pes
        groups.append([i for i in range(current_pes, total_pes)])
    return groups


def construct_group_variables(rank_groups, group_args):
    '''Return a dictionary of environment variables for each rank containing the
    associated ranks of all PEs in the group.
    '''
    env = {}
    for group_id, group in enumerate(rank_groups):
        for rank in group:
            var_name = GROUP_VAR_FORMAT.format(rank=rank)
            env[var_name] = '{gid} {cd}'.format(gid=group_id, cd=group_args[group_id].cd)
    return env


def print_output(env, aprun_args):
    '''Print the output to STDOUT for a shell to interpret.'''
    if '-b' not in aprun_args[:aprun_args.index('-n')]:
        log('WARNING',
            "Required aprun transfer bypass flag '-b' not explicitly set. "
            'Forcing transfer bypass.')
        aprun_args.insert(0, '-b')
    aprun_call = 'aprun ' + ' '.join(aprun_args)
    for key in sorted(env.keys()):
        print('{key}="{env}"'.format(key=key,env=env[key]))
    print('LD_PRELOAD={lib} '.format(lib=LIB_PATH) +
            aprun_call)


def main():
    '''Perform the sequence of steps needed to print the environment shell
    commands.
    '''

    local_args, aprun_args = parser()
    VERBOSE=local_args.debug
    log('INFO', 'Launching aprun in wrapped environment')
    group_args, mpmd_commands = get_independent_argstrings(aprun_args)
    groups = extract_group_ids(mpmd_commands)
    group_vars = construct_group_variables(groups, group_args)
    print_output(group_vars, [i for j in mpmd_commands for i in j])


#===============================================================================
if __name__ == '__main__':
    import sys
    try:
        main()
    except Exception as e:
        log('ERROR', 'Caught a python exception:')
        log('ERROR', str(e))
        sys.exit(1)

