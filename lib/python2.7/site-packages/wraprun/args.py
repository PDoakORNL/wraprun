from __future__ import print_function
import argparse
import sys
import os
from collections import OrderedDict

class ArgAction(argparse.Action):
    '''Base class for custom group argument argparse Actions.'''
    def __init__(self, *args, **kwargs):
        '''Create arparse.Action.'''
        super(ArgAction, self).__init__(*args, **kwargs)
        self.split = False
        self.cli = None

    def __call__(self, parser, namespace, values, option_string=None):
        '''Used by Argparse to process arguments.'''
        setattr(namespace, self.dest, values)
        self.cli = [option_string, values]


class FlagAction(ArgAction):
    '''Argparse action to processes MPMD group 'flag'-type arguments.'''
    def __init__(self, *args, **kwargs):
        '''Create arparse.Action for processing flag-type argument.'''
        default = kwargs.pop('default', None)
        const = kwargs.pop('const', True)
        nargs = kwargs.pop('nargs', 0)
        # TODO: add debugging warning if nargs != 0
        super(FlagAction, self).__init__(
            *args, default=default, nargs=0, const=const, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        '''Used by Argparse to process arguments.'''
        if self.const is not self.default:
            setattr(namespace, self.dest, self.const)
            self.cli = [option_string] if option_string is not None else None


class PesAction(ArgAction):
    '''Argparse action to process MPMD group "Processing Elements" (PES).

    Looks for rank colorsplitting as comma-separated integer lists of the form
        '-n x[,y]...'
    where 'x' and 'y' are integers.
    '''
    def __init__(self, *args, **kwargs):
        '''Create arparse.Action for processing PES argument.'''
        super(PesAction, self).__init__(*args, **kwargs)
        self.split = True

    def __call__(self, parser, namespace, values, option_string=None):
        '''Used by Argparse to process arguments.'''
        ranks_per_color = [int(i) for i in values.split(',')]
        setattr(namespace, self.dest, ranks_per_color)
        self.cli = [option_string, str(sum(ranks_per_color))]


class PathAction(ArgAction):
    '''Argparse action to process MPMD group CWD '--w-cd' arguments.

    Looks for rank colorsplitting as comma-separated path lists of the form
      --w-cd path1[,path2]...'
    where the paths cannot contain ','.
    '''
    def __init__(self, *args, **kwargs):
        '''Create arparse.Action for processing group CWD argument.'''
        super(PathAction, self).__init__(*args, **kwargs)
        self.split = True
        self.is_aprun_arg = False

    def __call__(self, parser, namespace, values, option_string=None):
        '''Used by Argparse to process arguments.'''
        paths_by_color = [i for i in values.split(',')]
        setattr(namespace, self.dest, paths_by_color)


class Argument(object):
    def __init__(self, name, **kwargs):
        self.name = name
        self.flags = kwargs.pop('flags', None)
        self.split = kwargs.pop('split', False)
        self.parser = kwargs.pop('parser')
        self._translator = kwargs.pop('formatter', None)

        self.parser['dest'] = self.name

        assert type(self.flags) in (list, type(None))

    def format(self, value):
        output = []
        if self.flags:
            output.append(self.flags[0])
            
        if self._translator is not None:
            output.append(self._translator(value))
        elif type(value) is list:
            for i in value:
                output.append(str(i))
        elif type(value) is bool:
            pass
        else:
            output.append(str(value))
        return output
        
    def add_to_parser(self, parser):
        if self.flags is not None:
            parser.add_argument(*self.flags, **self.parser)
        else:
            parser.add_argument(**self.parser)

    @property
    def default(self):
        return self.parser.get(
                'default',
                [None] if self.split else None)

class ArgumentListError(Exception):
    pass

class ArgumentList(object):
    def __init__(self, *args):
        self._args = OrderedDict()
        for arg in args:
            self._args[arg.name] = arg

    @property
    def names(self):
        return self._args.keys()

    @property
    def splits(self):
        return [k for k in self._args if self._args[k].split]

    def __iter__(self):
        for k,v in self._args.iteritems():
            yield v

    def __len__(self):
        return len(self._args)

    def __contains__(self, item):
        return item in self._args

    def __get__(self, name):
        return self._args[name]

    def __getitem__(self, name):
        return self._args[name]

    def get(self, name, default=None):
        return self._args.get(name, default)


class GlobalOptions(Options):
    def __init__(self):
        wraprun = ArgumentList(
            Argument(
                name='conf',
                flags=['--w-conf'],
                parser={
                    'help': 'Wraprun configuration file',
                    },
                ),
            Argument(
                name='debug',
                flags=['--w-debug'],
                parser={
                    'action': 'store_true',
                    'help': 'Print debugging information and exit',
                    },
                ),
            Argument(
                name='roe',
                flags=['--w-roe'],
                parser={
                    'action': 'store_true',
                    'help': 'DEPRECATED: Redirect group IO to separate files',
                    },
                ),
            )

        aprun = ArgumentList(
            Argument(
                name='nocopy',
                flags=['-b'],
                parser={
                    'action': 'store_true',
                    'help': 'Do not copy executable to compute nodes',
                    },
                ),
            )
        Options.__init__(self, wraprun, aprun)


class Options(object):
    def __init__(self, wraprun, aprun):
        self.wraprun = wraprun
        self.aprun = aprun

    def get(self, name):
        for l in (self.aprun, self.wraprun):
            try:
                return l[name]
            except KeyError:
                continue


class GroupOptions(Options):
    def __init__(self):
        self._coloring = None
        wraprun = ArgumentList(
            Argument(
                name='cd',
                flags=['--w-cd'],
                split=True,
                parser={
                    'metavar': "dir[,dir...]",
                    'default': ['./'],
                    'action': PathAction,
                    'help': 'Task working directory',
                    },
                ),
            )

        aprun = ArgumentList(
            Argument(
                name='pes',
                flags=['-n'],
                split=True,
                parser={
                    'metavar':"pes[,pes...]",
                    'required': True,
                    'action': PesAction,
                    'help': 'Number of processing elements (PEs). REQUIRED',
                    },
                formatter=lambda v: str(sum(v)),
                ),
            Argument(
                name='arch',
                flags=['-a'],
                parser={
                    'metavar': 'arch',
                    'action': ArgAction,
                    'help': 'Host architecture',
                    },
                ),
            Argument(
                name='cpu_list',
                flags=['-cc'],
                parser={
                    'metavar': 'list',
                    'action': ArgAction,
                    'help': 'CPU list',
                    },
                ),
            Argument(
                name='cpu_placement',
                flags=['-cp'],
                parser={
                    'metavar': 'file',
                    'action': ArgAction,
                    'help': 'CPU placement file',
                    },
                ),
            Argument(
                name='depth',
                flags=['-d'],
                parser={
                    'metavar': 'depth',
                    'action': ArgAction,
                    'help': 'Process affinity depth',
                    },
                ),
            Argument(
                name='cpus_per_cu',
                flags=['-j'],
                parser={
                    'metavar': 'cpupcu',
                    'action': ArgAction,
                    'help': 'CPUs per CU',
                    },
                ),
            Argument(
                name='node_list',
                flags=['-L'],
                parser={
                    'metavar': 'nodes',
                    'action': ArgAction,
                    'help': 'Node list',
                    },
                ),
            Argument(
                name='pes_per_node',
                flags=['-N'],
                parser={
                    'metavar': 'ppn',
                    'action': ArgAction,
                    'help': 'PEs per node'
                    },
                ),
            Argument(
                name='pes_per_numa_node',
                flags=['-S'],
                parser={
                    'metavar': 'ppnn',
                    'action': ArgAction,
                    'help': 'PEs per NUMA node'
                    },
                ),
            Argument(
                name='numa_node_list',
                flags=['-sl'],
                parser={
                    'metavar': 'list',
                    'nargs': 1,
                    'action': ArgAction,
                    'help': 'NUMA node list'
                    },
                ),
            Argument(
                name='numa_nodes_per_node',
                flags=['-sn'],
                parser={
                    'metavar': 'nnpn',
                    'nargs': 1,
                    'action': ArgAction,
                    'help': 'Number of NUMA nodes per node'
                    },
                ),
            Argument(
                name='strict_memory',
                flags=['-ss'],
                parser={
                    'nargs': 0,
                    'action': FlagAction,
                    'help': 'Use strict memory containment'
                    },
                ),
            Argument(
                name='exe',
                parser={
                    'metavar': 'exe [...]',
                    'nargs': argparse.REMAINDER,
                    'help': 'Executable and argument string. REQUIRED'
                    },
                ),
            )
        Options.__init__(self, wraprun, aprun)

    def coloring(self):
        if self._coloring is None:
            self._coloring = (
                    [k for k in self.wraprun.splits] +
                    [k for k in self.aprun.splits])
        return self._coloring



