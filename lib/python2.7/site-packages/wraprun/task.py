from collections import OrderedDict
from . import GROUP_OPTIONS
from .rank import Rank

class TaskError(Exception):
    pass

class TaskGroup(object):
    def __init__(self, first_rank=0, first_color=0, **kwargs):
        self._ranks = []
        self.args = OrderedDict.fromkeys(
            GROUP_OPTIONS.wraprun.names +
            GROUP_OPTIONS.aprun.names)
        for k in self.args:
            self.args[k] = kwargs.pop(k, GROUP_OPTIONS.get(k).default)
        self._balance()
        self._set_ranks(first_rank, first_color)

    def __repr__(self):
        return "TaskGroup(ranks=[{r0},{r1}], colors=[{c0},{c1}], exe='{exe}')".format(
            r0=self._ranks[0].rank, c0=self._ranks[0].color,
            r1=self._ranks[-1].rank, c1=self._ranks[-1].color,
            exe=self.args['exe'][0])

    @property
    def ranks(self):
        return self._ranks

    def _balance(self):
        splits = set()
        for k in GROUP_OPTIONS.coloring():
            value = self.args[k]
            if value is not None:
                if not isinstance(value, (tuple, list)):
                    value = [value]
                    self.args[k] = value
                if len(value) > 1:
                    splits.add(len(value))
        if len(splits) > 1:
            raise TaskError(
                'Inconsistent split lengths {0}'.format(splits))
        number_of_splits = max(splits) if splits else 1
        for k in GROUP_OPTIONS.coloring():
            value = self.args[k]
            if value is not None and len(value) != number_of_splits:
                # Len should be 1 and type should be tuple or list: be sure to
                # provide a default when adding new splitting options.
                self.args[k] = value * number_of_splits


    def last_rank_and_color(self):
        try:
            rank = self._ranks[-1].rank
            color = self._ranks[-1].color
        except IndexError:
            rank = None
            color = None
        return rank, color

    def _set_ranks(self, first_rank, first_color):
        ranks = []
        rank_id = first_rank
        for i, pes_count in enumerate(self.args['pes']):
            color = first_color + i
            if pes_count is None:
                raise WraprunError('Invalid PES')
            for _ in range(pes_count):
                rank = Rank(rank_id, color, path=self.args['cd'][i])
                ranks.append(rank)
                rank_id += 1
        self._ranks = ranks

    def file_lines(self):
        for rank in self._ranks:
            yield rank.string()

    def cli_args(self):
        arglist = []
        for k, arg in self.args.iteritems():
            if arg is None:
                continue
            setting = GROUP_OPTIONS.aprun.get(k, None)
            if setting is None:
                continue
            arglist.extend(setting.format(arg))
        return arglist


    def cli_string(self):
        return ' '.join(self.cli_args())
