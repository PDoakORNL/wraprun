#!/usr/bin/env python2

from __future__ import print_function
from collections import OrderedDict
import subprocess
import argparse
import sys
import os
import shlex
import tempfile

from args import GroupOptions, GlobalOptions, global_wraprun_options, global_aprun_options 

GROUP_OPTIONS = GroupOptions()
GLOBAL_OPTIONS = GlobalOptions()

class Parsers():
    def __init__(self):
        self._task_parser = argparse.ArgumentParser(add_help=False)
        self._add_args(GROUP_OPTIONS.wraprun, self._task_parser)
        self._add_args(GROUP_OPTIONS.aprun, self._task_parser)

    def _add_args(self, args, parser):
        for i in args:
            i.add_to_parser(parser)

    def parse_task(self, string):
        arglist = string.split()
        names = self._task_parser.parse_args(arglist)
        args = {k:v for k, v in names.__dict__.iteritems() if v is not None}
        if args['exe'][0] == '--':
            args['exe'].pop(0)
        return args

    def cli(self):
        parser = argparse.ArgumentParser(
            add_help=False,
            description='A flexible aprun task bundling tool.')

        global_opts = parser.add_argument_group(
            title='Global Options',
            description='Global options may only occur once and must precede the first task spec.')

        global_opts.add_argument(
                '-h',
                '--help',
                action='help',
                help='Show this help message and exit')

        self._add_args(global_wraprun_options, global_opts)
        self._add_args(global_aprun_options, global_opts)

        task = parser.add_argument_group(
                title='Defining Task Specs',
                description='''A task must have a number of PEs and an executable on Lustre.
                All Wraprun/Aprun options for the task must be given before the executable.
                Ambiguous option errors can be avoided by inserting the
                pseudo-argument '--' prior to the executable string.
                ''')

        self._add_args(GROUP_OPTIONS.wraprun, task)
        self._add_args(GROUP_OPTIONS.aprun, task)

        task_extra = parser.add_argument_group(
                title='Additional Task Specs',
                description='Each additional task spec is separated by " : ". ')
        task_extra.add_argument(
                'other_tasks',
                metavar=' : task',
                nargs="*",
                help="Optional additional tasks")
        return parser


class WraprunError(Exception):
    '''Class for managing wraprun-specific errors.'''
    pass


class Rank(object):
    '''Information about ranks within an MPMD task group.

    Stores the CWD and color of an MPI rank.
    '''
    # Ordered tuple of keys in output file lines.
    FILE_CONTENT = (
        'color',
        'path',
        )

    FILE_FORMAT = ' '.join(('{{{0}}}'.format(k) for k in FILE_CONTENT))

    def __init__(self, rank, color, **kwargs):
        '''Store data to be written to the rank parameters file.'''
        self.rank = rank
        self._data = {
            'color': color,
            'path': './',
            }
        self._data.update(kwargs)

    def __repr__(self):
        return 'Rank({0}:{1})'.format(self.rank, self._data['color'])

    def string(self):
        '''Return a rank data string for writing to the rank parameters file.'''
        return Rank.FILE_FORMAT.format(**self._data)

    @property
    def color(self):
        '''Return the rank 'color' integer.'''
        return self._data['color']



class Wraprun(object):
    def __init__(self, **kwargs):
        # Pick out config first.
        self._conf = kwargs.pop('conf', None)
        self._parsers = Parsers()
        
        # Set null defaults.
        self._options = {}
        self._task_groups = []
        self._env = None
        self._tmpfile = None
        self._ranks = 0
        self._colors = 0
        
        # Load parameters from conf, if given.
        if self._conf is not None:
            self._load_conf()
        
        # Passed args override/augment conf.
        for k, v in kwargs.iteritems():
            if k in global_wraprun_options.names():
                self._options[k] = v
        
        
    def __repr__(self):
        return "Wraprun(ranks={ranks}, colors={colors})".format(
                ranks=self._ranks, colors=self._colors)
        
    def _load_conf(self):
        self._options = options_from_conf
        for task_spec in task_groups_from_conf:
            self.add_task(**task_spec)


    def add_task(self, string=None, **kwargs):
        kwargs.update(first_rank=self._ranks, first_color=self._colors)
        if string is not None:
            kwargs.update(self._parsers.parse_task(string))
        task_group = TaskGroup(**kwargs)
        self._ranks, self._colors = [
                i + 1 for i in task_group.last_rank_and_color()]
        self._task_groups.append(task_group)
        self._update_file(task_group)

    def _debug_mode(self):
        return (not self._options.get('debug'))

    @property
    def _file(self):
        '''Return the File object for storing the wrapper rank parameters.'''
        if self._tmpfile is None or self._tmpfile.close_called:
            dir_path = self._options.get('scratch_dir', None)
            if dir_path is not None:
                try:
                    os.makedirs(dir_path, '0700')
                except OSError as err:
                    if err.errno is not 17:
                        raise
            self._tmpfile = tempfile.NamedTemporaryFile(
                'a+', prefix='wraprun_', suffix='.tmp', dir=dir_path,
                delete=self._debug_mode())
        return self._tmpfile

    def _update_file(self, task_group):
        tmpfile = self._file.file
        for rank in task_group.ranks:
            tmpfile.write(rank.string() + "\n")
        tmpfile.flush()

    @property
    def env(self):
        '''Return a dictionary of environment variables set by wraprun
        at runtime.'''
        try:
            if self._env is None:
                self._env = dict()
                self._env['LD_PRELOAD'] = os.environ['WRAPRUN_PRELOAD']
                self._env['WRAPRUN_FILE'] = self._file.name
                self._env['W_REDIRECT_OUTERR'] = '1'
                self._env['W_IGNORE_SEGV'] = '1'
                self._env['W_UNSET_PRELOAD'] = '1'
            return self._env
        except KeyError as e:
            self._env = None
            raise (WraprunError,
                   'Missing {v} environment variable'.format(v=e),
                   sys.exc_info()[2])


    def _cli_opts(self):
        arglist = []
        for k, v in self._options.iteritems():
            if v is None:
                continue
            op = GLOBAL_OPTIONS.aprun.get(k, None)
            if op is None:
                continue
            arglist.extend(op.format(v))
        return arglist

    def _arg_list(self):
        args = []
        for i, tg in enumerate(self._task_groups):
            if i > 0:
                args.append(':')
            args.extend(tg.cli_args())
        return args


    def launch(self):
        os.environ.update(self.env)

        # Last chance to update the log.
        sys.stdout.flush()
        if not self._debug_mode():
            #log('INFO', 'Launching aprun in wrapped environment')
            aprun = subprocess.Popen(
                shlex.split(self.args.string()),
                env=os.environ)
            aprun.wait()
        else:
            pass
            #log('WARNING', 'Job not launched due to debugging.')
            #log('DEBUG', 'Input Arguments:')
            #arglines = (" ".join(sys.argv)).split(':')
            #for i, group in enumerate(arglines):
            #    if i == 0:
            #        log('DEBUG', '  {0}'.format(group))
            #    else:
            #        log('DEBUG', '    : {0}'.format(group))
            #log('DEBUG', 'Environment Modifications:')
            #for var, val in self.env.items():
            #    log('DEBUG', '  {0}={1}'.format(var, val))
            #log('DEBUG', 'Aprun Invocation:')
            #log('DEBUG', '  {0}'.format(self.args.string()))
            #log('DEBUG', 'Rank Parameters File:')
            #width = len(str(self.groups[-1].last_rank))
            #self.file.file.seek(0)
            #for line_number, line in enumerate(self.file.file.readlines()):
            #    log('DEBUG', '  {ln:0{width}d}|{line}'.format(
            #        ln=line_number, width=width, line=line[:-1]))
    

class TaskGroup(object):
    def __init__(self, first_rank=0, first_color=0, **kwargs):
        self._ranks = []
        self.args = OrderedDict.fromkeys(
                GROUP_OPTIONS.wraprun.names +
                GROUP_OPTIONS.aprun.names)
        for k in self.args:
            self.args[k] = kwargs.pop(k, GROUP_OPTIONS.get(k).default)
        self._balance()
        self._set_ranks(first_rank, first_color)

    def __repr__(self):
        return "TaskGroup(ranks=[{r0},{r1}], colors=[{c0},{c1}], exe='{exe}')".format(
                r0=self._ranks[0].rank, c0=self._ranks[0].color,
                r1=self._ranks[-1].rank, c1=self._ranks[-1].color,
                exe=self.args['exe'][0])

    @property
    def ranks(self):
        return self._ranks

    def _balance(self):
        splits = set()
        for k in GROUP_OPTIONS.coloring():
            value = self.args[k]
            if value is not None:
                if type(value) not in (tuple, list):
                    value = [value]
                    self.args[k] = value
                if len(value) > 1:
                    splits.add(len(value))
        if len(splits) > 1:
            raise WraprunError(
                    'Inconsistent split lengths {0}'.format(splits))
        number_of_splits = max(splits) if splits else 1
        for k in GROUP_OPTIONS.coloring():
            value = self.args[k]
            if value is not None and len(value) != number_of_splits:
                # Len should be 1 and type should be tuple or list: be sure to
                # provide a default when adding new splitting options.
                self.args[k] = value * number_of_splits


    def last_rank_and_color(self):
        try:
            rank = self._ranks[-1].rank
            color = self._ranks[-1].color
        except IndexError:
            rank = None
            color = None
        return rank, color

    
    def _set_ranks(self, first_rank, first_color):
        ranks = []
        rank_id = first_rank
        for i, n in enumerate(self.args['pes']):
            color = first_color + i
            if n is None:
                raise WraprunError('Invalid PES')
            for j in range(n):
                rank = Rank(rank_id, color, path=self.args['cd'][i])
                ranks.append(rank)
                rank_id += 1
        self._ranks = ranks

    def file_lines(self):
        for rank in self._ranks:
            yield rank.string()


    def cli_args(self):
        arglist = []
        for k, v in self.args.iteritems():
            if v is None:
                continue
            op = GROUP_OPTIONS.aprun.get(k, None)
            if op is None:
                continue
            arglist.extend(op.format(v))
        return arglist


    def cli_string(self):
        return ' '.join(self.cli_args())
