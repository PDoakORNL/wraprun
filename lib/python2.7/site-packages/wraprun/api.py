#!/usr/bin/env python

from __future__ import print_function
from collections import OrderedDict
import subprocess
import argparse
import sys
import os
import shlex
import tempfile

from args import global_wraprun_options, global_aprun_options, group_wraprun_options, group_aprun_options

def CLIParser():
    parser = argparse.ArgumentParser(
            add_help=False,
            description='A flexible aprun task bundling tool.')

    global_opts = parser.add_argument_group(
            title='Global Options',
            description='Global options may only occur once and must precede the first task spec.')

    global_opts.add_argument(
            '-h',
            '--help',
            action='help',
            help='Show this help message and exit')

    for k, v in global_wraprun_options.iteritems():
        global_opts.add_argument(
                '--w-' + k,
                **v['parse_opts'])
    for k, v in global_aprun_options.iteritems():
        global_opts.add_argument(
                *v['parse_args'],
                **v['parse_opts'])

    task_parser = parser.add_argument_group(
            title='Defining Task Specs',
            description='''A task must have a number of PEs and an executable on Lustre.
            All Wraprun/Aprun options for the task must be given before the executable.''')

    for k, v in group_wraprun_options.iteritems():
        task_parser.add_argument(
                '--w-' + k,
                **v['parse_opts'])
    for k, v in group_aprun_options.iteritems():
        task_parser.add_argument(
                *v['parse_args'],
                **v['parse_opts'])

    extra_tasks = parser.add_argument_group(
            title='Additional Task Specs',
            description='Each additional task spec is separated by " : ". ')
    extra_tasks.add_argument(
            'other_tasks',
            metavar=' : task',
            nargs="*",
            help="Optional additional tasks")

    return parser


class WraprunError(Exception):
    '''Class for managing wraprun-specific errors.'''
    pass


class Rank(object):
    '''Information about ranks within an MPMD task group.

    Stores the CWD and color of an MPI rank.
    '''
    # Ordered tuple of keys in output file lines.
    FILE_CONTENT = (
        'color',
        'path',
        )

    FILE_FORMAT = ' '.join(('{{{0}}}'.format(k) for k in FILE_CONTENT))

    def __init__(self, rank, color, **kwargs):
        '''Store data to be written to the rank parameters file.'''
        self.rank = rank
        self._data = {
            'color': color,
            'path': './',
            }
        self._data.update(kwargs)

    def __repr__(self):
        return 'Rank({0}:{1})'.format(self.rank, self._data['color'])

    def string(self):
        '''Return a rank data string for writing to the rank parameters file.'''
        return Rank.FILE_FORMAT.format(**self._data)

    @property
    def color(self):
        '''Return the rank 'color' integer.'''
        return self._data['color']



class Wraprun(object):
    def __init__(self, **kwargs):
        # Pick out config first.
        self._conf = kwargs.pop('conf', None)
        
        # Set null defaults.
        self._options = {}
        self._task_groups = []
        self._env = {}
        self._ranks = 0
        self._colors = 0
        
        # Load parameters from conf, if given.
        if self._conf is not None:
            self._load_conf()
        
        # Passed args override/augment conf.
        for k, v in kwargs.iteritems():
            if k in global_wraprun_options:
                self._options[k] = v
        
        # TODO: This is meant to be used as python API, so adding
        # task groups not from a file, should be done using the
        # add_task method. A CLI binary should be built around this API.
        
        
    def _load_conf(self):
        self._options = options_from_conf
        for task_spec in task_groups_from_conf:
            self.add_task(**task_spec)


    def add_task(self, **kwargs):
        kwargs.update(first_rank=self._ranks, first_color=self._colors)
        task_group = TaskGroup(**kwargs)
        self._ranks, self._colors = [
                i + 1 for i in task_group.last_rank_and_color()]
        self._task_groups.append(task_group)


    def launch(self):
        pass
    

class TaskGroup(object):
    SPLIT_OPTIONS = (
            [k for k, v in group_wraprun_options.iteritems()
                if v.has_key('split')] +
            [k for k, v in group_aprun_options.iteritems()
                if v.has_key('split')])


    def __init__(self, first_rank=0, first_color=0, string=None, **kwargs):
        self._ranks = []
        self.args = OrderedDict.fromkeys(
                group_wraprun_options.keys() + group_aprun_options.keys())
        for k in self.args.keys():
            self.args[k] = kwargs.pop(k,
                    [None] if k in TaskGroup.SPLIT_OPTIONS else None)
        self._normalize_splits()
        self._set_ranks(first_rank, first_color)


    def _normalize_splits(self):
        splits = set()
        for k in TaskGroup.SPLIT_OPTIONS:
            value = self.args[k]
            if value is not None:
                if type(value) not in (tuple, list):
                    value = [value]
                    self.args[k] = value
                if len(value) > 1:
                    splits.add(len(value))
        if len(splits) > 1:
            raise WraprunError(
                    'Inconsistent split lengths {0}'.format(splits))
        number_of_splits = max(splits) if splits else 1
        for k in TaskGroup.SPLIT_OPTIONS:
            value = self.args[k]
            if value is not None and len(value) != number_of_splits:
                # Len should be 1 and type should be tuple or list: be sure to
                # provide a default when adding new splitting options.
                self.args[k] = value * number_of_splits


    def last_rank_and_color(self):
        try:
            rank = self._ranks[-1].rank
            color = self._ranks[-1].color
        except IndexError:
            rank = None
            color = None
        return rank, color

    
    def _set_ranks(self, first_rank, first_color):
        ranks = []
        rank_id = first_rank
        for i, n in enumerate(self.args['pes']):
            color = first_color + i
            if n is None:
                raise WraprunError('Invalid PES')
            for j in range(n):
                rank = Rank(rank_id, color, path=self.args['cd'][i])
                ranks.append(rank)
                rank_id += 1
        self._ranks = ranks
        

    def args_string(self):
        return ' '.join(self.args)
