"""
This module provides the primary user interface to wraprun.

The following classes are defined:
    WraprunError - for managing wraprun exceptions.
    Wraprun      - the primary wraprun API object.
"""

from __future__ import print_function
import subprocess
import sys
import os
import tempfile

from .options import GROUP_OPTIONS, GLOBAL_OPTIONS
from .parsers import TaskParser, create_cli_parser
from .task import TaskGroup

class WraprunError(Exception):
    '''Class for managing wraprun-specific errors.'''
    pass

class Wraprun(object):
    """Job bundler for aprun."""
    def __init__(self, argv=None, **kwargs):
        """API constructor.

        Takes a list 'argv' of CLI argument strings or keyword arguments
        corresponding to contents of wraprun.GLOBAL_OPTIONS.
        """
        # Take arguments from cli/argv xor kwargs.
        if kwargs and argv:
            raise WraprunError("Use either CLI or API, not both.")

        # Set null defaults.
        self._parser = TaskParser()
        self._options = {}
        self._task_groups = []
        self._env = None
        self._tmpfile = None
        self._rank_and_color = {'rank':0, 'color':0}

        # This funtionality might be better merged into TaskParser
        if argv is not None:
            cli_parser = create_cli_parser()
            try:
                first_group_marker = argv.index(':')
            except ValueError:
                first_group_marker = len(argv)
            known_args = cli_parser.parse_args(argv[1:first_group_marker])
            self._options.update(GLOBAL_OPTIONS.all_args(known_args))
            self.add_task(**(GROUP_OPTIONS.all_args(known_args)))
            for string in ' '.join(argv[first_group_marker + 1:]).split(':'):
                self.add_task(string=string)

        if kwargs:
            # Pick out config first.
            self._conf = kwargs.pop('conf', None)

            # Load parameters from conf, if given.
            if self._conf is not None:
                self._load_conf()

            # Explicitly passed args override/augment conf.
            for k, arg in kwargs.iteritems():
                if k in GLOBAL_OPTIONS.wraprun.names():
                    self._options[k] = arg


    def __repr__(self):
        """Wraprun representation."""
        return "Wraprun(ranks={rank}, colors={color})".format(
            **self._rank_and_color)

    def _load_conf(self):
        """NOT IMPLEMENTED. Sets API global options and tasks from the
        configuration file passed to the class constructor.
        """
        # read configuration file
        # populate options
        # populate tasks
        raise NotImplementedError

    def add_task(self, string=None, **kwargs):
        """Add a task spec.

        Takes either a string of CLI arguments or keyword arguments corresponding
        to the contents of wraprun.GROUP_OPTIONS.

        EXAMPLES:
           add_task('-n 1,2,3 --w-cd ./a,./b,./c ./exe exe_arg')
           add_task(pes=[1,2,3], cd=['./a','./b','./c'] ,exe='./exe exe_arg')
        """
        kwargs.update(
            {"first_" + k: v for k, v in self._rank_and_color.iteritems()})
        if string is not None:
            kwargs.update(self._parser.parse_task(string))
        task_group = TaskGroup(**kwargs)
        self._rank_and_color = {
            k:v + 1 for k, v in task_group.last_rank_and_color().iteritems()}
        self._task_groups.append(task_group)
        self._update_file(task_group)

    def _debug_mode(self):
        """Return True if debugging option is set."""
        return self._options.get('debug')

    @property
    def _file(self):
        """Return the File object for storing the wrapper rank parameters."""
        if self._tmpfile is None or self._tmpfile.close_called:
            dir_path = self._options.get('scratch_dir', None)
            if dir_path is not None:
                try:
                    os.makedirs(dir_path, '0700')
                except OSError as err:
                    if err.errno is not 17:
                        raise
            self._tmpfile = tempfile.NamedTemporaryFile(
                'a+', prefix='wraprun_', suffix='.tmp', dir=dir_path,
                delete=not self._debug_mode())
        return self._tmpfile

    def _update_file(self, task_group):
        """Write rank runtime parameters of task_group to file."""
        tmpfile = self._file.file
        for rank in task_group.ranks:
            tmpfile.write(rank.string() + "\n")
        tmpfile.flush()

    @property
    def env(self):
        """Return the dictionary of wraprun runtime environment variables."""
        try:
            if self._env is None:
                self._env = dict()
                self._env['LD_PRELOAD'] = os.environ['WRAPRUN_PRELOAD']
                self._env['WRAPRUN_FILE'] = self._file.name
                self._env['W_REDIRECT_OUTERR'] = '1'
                self._env['W_IGNORE_SEGV'] = '1'
                self._env['W_UNSET_PRELOAD'] = '1'
            return self._env
        except KeyError as error:
            self._env = None
            raise WraprunError, \
                  'Missing {v} environment variable'.format(v=error), \
                  sys.exc_info()[2]


    def _aprun_arglist(self):
        """Return a list of the global CLI strings to pass to aprun."""
        arglist = []
        for k, value in self._options.iteritems():
            if value is None:
                continue
            option = GLOBAL_OPTIONS.aprun.get(k, None)
            if option is None:
                continue
            arglist.extend(option.format(value))
        return arglist

    def _task_arglist(self):
        """Return a list of the task CLI strings to pass to aprun."""
        args = []
        for i, task_group in enumerate(self._task_groups):
            if i > 0:
                args.append(':')
            args.extend(task_group.cli_args())
        return args

    def _subprocess_args(self):
        """Return a list of CLI strings needed to invoke aprun."""
        return ['aprun'] + self._aprun_arglist() + self._task_arglist()

    def launch(self):
        """Launch an aprun subprocess with all bundled tasks."""
        os.environ.update(self.env)
        # Last chance to update the log.
        sys.stdout.flush()
        if not self._debug_mode():
            aprun = subprocess.Popen(
                self._subprocess_args(),
                env=os.environ)
            aprun.wait()
        else:
            # Print debugging information
            print("Running in debugging mode.")
            print(' '.join(self._subprocess_args()), '\n')
            for k, v in self.env.iteritems():
                print(k, "=", v, sep="")
            print('\n', self.__repr__(), sep='')
            self._file.file.seek(0)
            width = len(str(self._rank_and_color['rank']))
            for line_number, line in enumerate(self._file.file.readlines()):
                print('DEBUG', '  {ln:0{width}d}|{line}'.format(ln=line_number, width=width, line=line[:-1]))
