from .parseractions import *
from .arguments import Argument, ArgumentList

class OptionsBase(object):
    def __init__(self, wraprun, aprun):
        self.wraprun = wraprun
        self.aprun = aprun
        self._coloring = None

    def get(self, name):
        for l in (self.aprun, self.wraprun):
            try:
                return l[name]
            except KeyError:
                continue

    def coloring(self):
        if self._coloring is None:
            self._coloring = (
                    [k for k in self.wraprun.splits] +
                    [k for k in self.aprun.splits])
        return self._coloring

    def wraprun_args(self, namespace):
        return {k:getattr(namespace, k) for k in self.wraprun.names
                if getattr(namespace, k) is not None}

    def aprun_args(self, namespace):
        return {k:getattr(namespace, k) for k in self.aprun.names
                if getattr(namespace, k) is not None}

    def all_args(self, namespace):
        return {k:getattr(namespace, k) for k in (
            self.wraprun.names + self.aprun.names)
                if getattr(namespace, k) is not None}


class GlobalOptions(OptionsBase):
    def __init__(self):
        wraprun = ArgumentList(
            Argument(
                name='conf',
                flags=['--w-conf'],
                parser={
                    'help': 'Wraprun configuration file',
                    },
                ),
            Argument(
                name='debug',
                flags=['--w-debug'],
                parser={
                    'action': FlagAction,
                    'help': 'Print debugging information and exit',
                    },
                ),
            Argument(
                name='roe',
                flags=['--w-roe'],
                parser={
                    'action': FlagAction,
                    'help': 'DEPRECATED: Redirect group IO to separate files',
                    },
                ),
            )

        aprun = ArgumentList(
            Argument(
                name='nocopy',
                flags=['-b'],
                parser={
                    'action': FlagAction,
                    'help': 'Do not copy executable to compute nodes',
                    },
                ),
            )
        OptionsBase.__init__(self, wraprun, aprun)


class GroupOptions(OptionsBase):
    def __init__(self):
        wraprun = ArgumentList(
            Argument(
                name='cd',
                flags=['--w-cd'],
                split=True,
                parser={
                    'metavar': "dir[,dir...]",
                    'default': ['./'],
                    'action': PathAction,
                    'help': 'Task working directory',
                    },
                ),
            )

        aprun = ArgumentList(
            Argument(
                name='pes',
                flags=['-n'],
                split=True,
                parser={
                    'metavar':"pes[,pes...]",
                    'required': True,
                    'action': PesAction,
                    'help': 'Number of processing elements (PEs). REQUIRED',
                    },
                formatter=lambda v: str(sum(v)),
                ),
            Argument(
                name='arch',
                flags=['-a'],
                parser={
                    'metavar': 'arch',
                    'action': ArgAction,
                    'help': 'Host architecture',
                    },
                ),
            Argument(
                name='cpu_list',
                flags=['-cc'],
                parser={
                    'metavar': 'list',
                    'action': ArgAction,
                    'help': 'CPU list',
                    },
                ),
            Argument(
                name='cpu_placement',
                flags=['-cp'],
                parser={
                    'metavar': 'file',
                    'action': ArgAction,
                    'help': 'CPU placement file',
                    },
                ),
            Argument(
                name='depth',
                flags=['-d'],
                parser={
                    'metavar': 'depth',
                    'action': ArgAction,
                    'help': 'Process affinity depth',
                    },
                ),
            Argument(
                name='cpus_per_cu',
                flags=['-j'],
                parser={
                    'metavar': 'cpupcu',
                    'action': ArgAction,
                    'help': 'CPUs per CU',
                    },
                ),
            Argument(
                name='node_list',
                flags=['-L'],
                parser={
                    'metavar': 'nodes',
                    'action': ArgAction,
                    'help': 'Node list',
                    },
                ),
            Argument(
                name='pes_per_node',
                flags=['-N'],
                parser={
                    'metavar': 'ppn',
                    'action': ArgAction,
                    'help': 'PEs per node'
                    },
                ),
            Argument(
                name='pes_per_numa_node',
                flags=['-S'],
                parser={
                    'metavar': 'ppnn',
                    'action': ArgAction,
                    'help': 'PEs per NUMA node'
                    },
                ),
            Argument(
                name='numa_node_list',
                flags=['-sl'],
                parser={
                    'metavar': 'list',
                    'nargs': 1,
                    'action': ArgAction,
                    'help': 'NUMA node list'
                    },
                ),
            Argument(
                name='numa_nodes_per_node',
                flags=['-sn'],
                parser={
                    'metavar': 'nnpn',
                    'nargs': 1,
                    'action': ArgAction,
                    'help': 'Number of NUMA nodes per node'
                    },
                ),
            Argument(
                name='strict_memory',
                flags=['-ss'],
                parser={
                    'nargs': 0,
                    'action': FlagAction,
                    'help': 'Use strict memory containment'
                    },
                ),
            Argument(
                name='exe',
                parser={
                    'metavar': 'exe [...]',
                    'nargs': argparse.REMAINDER,
                    'help': 'Executable and argument string. REQUIRED'
                    },
                ),
            )
        OptionsBase.__init__(self, wraprun, aprun)


